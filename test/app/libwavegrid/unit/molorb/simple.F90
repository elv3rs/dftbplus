!--------------------------------------------------------------------------------------------------!
!  DFTB+: general package for performing fast atomistic simulations                                !
!  Copyright (C) 2006 - 2025  DFTB+ developers group                                               !
!                                                                                                  !
!  See the LICENSE file for terms of usage and distribution.                                       !
!--------------------------------------------------------------------------------------------------!

#:include "fortuno_serial.fypp"

module test_libwavegrid_simple
  use test_libwavegrid_initmolorb, only : initMolorbH2O, initMolorbHchain
  use dftbp_common_accuracy, only : dp
  use libwavegrid, only : TSlaterOrbital, TSpeciesBasis, TMolecularOrbital, &
                       & getValue, getAtomicDensities, getTotalChrg
  use dftbp_type_typegeometry, only : TGeometry
  use dftbp_common_status, only : TStatus
  use dftbp_math_simplealgebra, only : determinant33
  use dftbp_dftb_boundarycond, only : TBoundaryConds, boundaryCondsEnum, TBoundaryConds_init
  use fortuno_serial, only : suite => serial_suite_item, test_list, is_close, &
    serial_case_base, test_item 
  $:FORTUNO_SERIAL_IMPORTS()
  implicit none

  private
  public :: tests

  type :: TSpotCheckReal
    integer :: idx(4)
    real(dp) :: expected
  end type TSpotCheckReal

  type :: TSpotCheckComplex
    integer :: idx(4)
    complex(dp) :: expected
  end type TSpotCheckComplex

  
  !> Launch config for molorb tests
  type :: TLaunchConfig
    logical :: useRadialLut = .false.
    logical :: useGPU = .false. 
  end type

  !> All 4 combinations of LUT/Direct and CPU/GPU
  type(TLaunchConfig), parameter :: launchConfigs(4) = [ &
      TLaunchConfig(.false., .false.), & ! Direct CPU
      TLaunchConfig(.true.,  .false.), & ! LUT CPU
      TLaunchConfig(.false., .true. ), & ! Direct GPU
      TLaunchConfig(.true.,  .true. )  & ! LUT GPU
  ]


  type, extends(serial_case_base), abstract :: TConfiguredTest
    type(TLaunchConfig) :: config
  end type TConfiguredTest

  !! Subclasses for each test case
  type, extends(TConfiguredTest) :: TConfiguredTest_real_totChrg
  contains
    procedure :: run => TConfiguredTest_real_totChrg_run
  end type TConfiguredTest_real_totChrg

  type, extends(TConfiguredTest) :: TConfiguredTest_real_atomDens
  contains
    procedure :: run => TConfiguredTest_real_atomDens_run
  end type TConfiguredTest_real_atomDens

  type, extends(TConfiguredTest) :: TConfiguredTest_real_allStates
  contains
    procedure :: run => TConfiguredTest_real_allStates_run
  end type TConfiguredTest_real_allStates

  type, extends(TConfiguredTest) :: TConfiguredTest_complex_totChrg
  contains
    procedure :: run => TConfiguredTest_complex_totChrg_run
  end type TConfiguredTest_complex_totChrg

  type, extends(TConfiguredTest) :: TConfiguredTest_complex_allStates
  contains
    procedure :: run => TConfiguredTest_complex_allStates_run
  end type TConfiguredTest_complex_allStates




  !> Allow 0.1% relative error (LUT interpolation etc.)
  real(dp), parameter :: rtol = 1.0e-3_dp
  !> Real Eigenvectors for H2O molecule
  real(dp), parameter :: eigVecsReal(6,4) = reshape([ &
       0.93075335285360816_dp,       5.4749851762277632E-003_dp,   6.5189438567696949E-019_dp,  0.0000000000000000_dp,       &
      -0.11131233240146322_dp,      -0.11131233240146322_dp,      -0.27821574567737223_dp,     -0.73551457100773243_dp,      &
      -7.8726661848432967E-018_dp,   0.0000000000000000_dp,      -0.33117590117481399_dp,      -0.33117590117481405_dp,      &
       2.7154435594648282E-018_dp,  -9.9931138111063277E-018_dp,  0.73160204739108692_dp,       1.1102230246251565E-016_dp,  &
       0.39813631802212995_dp,      -0.39813631802212995_dp,      3.7150709608707145E-033_dp,  -8.1237292785459783E-033_dp,  &
       9.7504438592516575E-017_dp,   1.0000000000000000_dp,      -6.6858833593547624E-017_dp,   6.6858833593547636E-017_dp], &
       & [6,4])
  !> Atomic density occupations for H2O per Orb(distributed evenly over same angMom)
  real(dp), parameter :: occupationAtomDens(6,1) = reshape([2.0_dp, 4.0_dp / 3.0_dp, 4.0_dp / 3.0_dp, 4.0_dp / 3.0_dp, 1.0_dp,&
  1.0_dp], [6,1])
  !> Occupation per state as computed by DFTB+
  real(dp), parameter :: occupationVecH2O(4) = [2.0_dp, 2.0_dp, 2.0_dp, 2.0_dp]

  !> Complex eigenvectors for H chain
  complex(dp), parameter :: eigVecsComplex(1,4) = reshape([ &
       (0.62981679983963734_dp, 0.0_dp), (0.68885855972586518_dp, 0.0_dp), &
       (0.81991408755170758_dp, 0.0_dp), (1.0501565770378785_dp, 0.0_dp) &
       ], [1,4])
  !> Occupation per state as computed by DFTB+
  real(dp), parameter :: occupationVecHchain(4) = [0.25_dp, 0.25_dp, 0.25_dp, 0.25_dp]
  !> k-points for H chain
  real(dp), parameter :: kPointsHchain(3,8) = reshape([ &
       0.0_dp, 0.0_dp, 0.19634954084936207_dp, 0.0_dp, 0.0_dp, 0.58904862254808621_dp, 0.0_dp, 0.0_dp, &
       0.98174770424681035_dp, 0.0_dp, 0.0_dp, 1.3744467859455345_dp, 0.0_dp, 0.0_dp, 1.7671458676442586_dp, &
       0.0_dp, 0.0_dp, 2.1598449493429825_dp, 0.0_dp, 0.0_dp, 2.5525440310417071_dp, 0.0_dp, 0.0_dp, &
       2.9452431127404308_dp], [3,8])
  integer, parameter :: kIndexesHchain(4) = [1, 2, 3, 4]


contains
  ! ### Real (H2O) Test cases ###

  ! -- Real (H2O) : Total charge calculation --
  subroutine TConfiguredTest_real_totChrg_run(this)
    class(TConfiguredTest_real_totChrg), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp) :: valueOnGrid(100,100,100,1)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    type(TSpotCheckReal) :: spotChecks(6) = [ &
        TSpotCheckReal([50, 31, 50, 1], 1.009617874235818_dp), & ! O at (0,-1.89,0)
        TSpotCheckReal([1, 1, 1, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([100, 100, 100, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([51, 51, 51, 1], 0.6092945991929660E-01_dp), & ! Grid Center
        TSpotCheckReal([50, 40, 51, 1], 0.5131651070097035_dp), & ! Symmetry: molecule in YZ plane
        TSpotCheckReal([52, 40, 51, 1], 0.5131651070097035_dp) & ! Symmetric: molecule in YZ plane
    ]

    call initMolorbH2O(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))

    ! Main calculation
    call getTotalChrg(molorb, eigVecsReal, valueOnGrid, occupationVecH2O, this%config%useGPU)
    ! CheckReal sum over grid
    expected = 8.0040445629655839_dp
    actual = sum(valueOnGrid) * gridVol
    print *, "Total charge:", actual
    @:CHECK(is_close(actual, expected, rtol=rtol))
    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_real_totChrg_run

  ! -- Real (H2O) : Atomic densities calculation --
  subroutine TConfiguredTest_real_atomDens_run(this)
    class(TConfiguredTest_real_atomDens), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp) :: valueOnGrid(100,100,100,1)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    type(TSpotCheckReal) :: spotChecks(6) = [ &
        TSpotCheckReal([50, 31, 50, 1], 1.238914874283217_dp), & ! O at (0,-1.89,0)
        TSpotCheckReal([1, 1, 1, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([100, 100, 100, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([51, 51, 51, 1], 0.5835226183394406E-01_dp), & ! Grid Center
        TSpotCheckReal([50, 40, 51, 1], 0.6846187059267557_dp), & ! Symmetry: molecule in YZ plane
        TSpotCheckReal([52, 40, 51, 1], 0.6846187059267551_dp) & ! Symmetric: molecule in YZ plane
    ]

    call initMolorbH2O(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))

    ! Main calculation
    call getAtomicDensities(molorb, occupationAtomDens, valueOnGrid, this%config%useGPU)
    ! CheckReal sum over grid
    expected = 8.004352_dp
    actual = sum(valueOnGrid) * gridVol
    print *, "Total charge:", actual
    @:CHECK(is_close(actual, expected, rtol=rtol))
    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_real_atomDens_run

  ! -- Real (H2O) : All states calculation --
  subroutine TConfiguredTest_real_allStates_run(this)
    class(TConfiguredTest_real_allStates), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp) :: valueOnGrid(100,100,100,4)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    ! 2 randomly chosen points per state.
    ! [random.randrange(1,101) for _ in "123"] 
    type(TSpotCheckReal) :: spotChecks(8) = [ &
        TSpotCheckReal([31, 82, 52, 1], -0.4237591897694508E-03_dp), & 
        TSpotCheckReal([93, 19, 63, 1], -0.8172698875983751E-04_dp), & 
        TSpotCheckReal([80, 82, 83, 2], -0.1274610827226662E-03_dp), & 
        TSpotCheckReal([32, 28, 73, 2], -0.2681614272853517E-03_dp), & 
        TSpotCheckReal([68, 17, 95, 3],  0.1151590378991745E-03), & 
        TSpotCheckReal([39, 88, 09, 3], -0.9397073043782955E-04_dp), & 
        TSpotCheckReal([09, 78, 23, 4],  0.4296017603685945E-20_dp), & 
        TSpotCheckReal([47, 59, 06, 4], -0.9990029155728657E-06_dp)  & 
    ]

    call initMolorbH2O(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))
    
    ! Main calculation
    call getValue(molorb, eigVecsReal, valueOnGrid, this%config%useGPU)
    ! CheckReal sum over grid
    expected = -11.36846731051559_dp
    actual = sum(valueOnGrid) * gridVol
    print *, "Total charge:", actual
    @:CHECK(is_close(actual, expected, rtol=rtol))
    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_real_allStates_run


  ! ### Complex (H-chain) Test cases ###
  ! -- Complex (H-chain) : Total charge calculation --
  subroutine TConfiguredTest_complex_totChrg_run(this)
    class(TConfiguredTest_complex_totChrg), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp) :: valueOnGrid(100,100,100,1)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    ! Randomly chosen points.
    ! [random.randrange(1,101) for _ in "123"] 
    type(TSpotCheckReal) :: spotChecks(6) = [ &
        TSpotCheckReal([31, 82, 52, 1], 0.1854186607568482E-04_dp), & 
        TSpotCheckReal([93, 19, 63, 1], 0.4554475419034117E-08_dp), & 
        TSpotCheckReal([80, 82, 83, 1], 0.1400485004792566E-05_dp), & 
        TSpotCheckReal([32, 28, 73, 1], 0.2821278119060284E-03_dp), & 
        TSpotCheckReal([68, 17, 95, 1], 0.1144197239608134E-04_dp), & 
        TSpotCheckReal([39, 88, 09, 1], 0.7705316328219835E-05_dp) & 
    ]
    call initMolorbHchain(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))
    ! Main calculation
    call getTotalChrg(molorb, eigVecsComplex, kPointsHchain, kIndexesHchain, valueOnGrid, occupationVecHchain, this%config%useGPU)
    ! CheckReal sum over grid
    expected = 6.637263751554149_dp
    actual = sum(valueOnGrid) * gridVol
    print *, "Total charge:", actual
    @:CHECK(is_close(actual, expected, rtol=rtol))
    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_complex_totChrg_run


  ! -- Complex (H-chain) : All states calculation --
  subroutine TConfiguredTest_complex_allStates_run(this)
    class(TConfiguredTest_complex_allStates), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    complex(dp) :: valueOnGrid(100,100,100,4)
    real(dp) :: gridVol
    complex(dp) :: actual, expected
    integer :: i, idx(4)
    ! 2 randomly chosen points per state.
    ! [random.randrange(1,101) for _ in "123"] 
    type(TSpotCheckComplex) :: spotChecks(8) = [ &
        TSpotCheckComplex([31, 82, 52, 1], (0.4618562431412820E-02_dp, 0.5805855442516971E-04_dp)), &
        TSpotCheckComplex([93, 19, 63, 1], (0.8330079947653005E-04_dp, 0.8753533677015034E-05_dp)), &
        TSpotCheckComplex([80, 82, 83, 2], (0.1222651639518469E-02_dp, 0.8048672887188940E-04_dp)), &
        TSpotCheckComplex([32, 28, 73, 2], (0.1690763857502260E-01_dp, 0.4646391064170055E-02_dp)), &
        TSpotCheckComplex([68, 17, 95, 3], (0.2091620118572572E-02_dp, 0.2596145058129883E-02_dp)), &
        TSpotCheckComplex([39, 88, 09, 3], (0.2671119431633243E-02_dp, 0.5944536018057613E-03_dp)), &
        TSpotCheckComplex([09, 78, 23, 4], (0.8227151295698438E-04_dp, 0.1991128564447004E-04_dp)), &
        TSpotCheckComplex([47, 59, 06, 4], (0.2967129806717818_dp, 0.8175874030009455E-02_dp)) &
    ]

    call initMolorbHchain(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))
    ! Main calculation
    call getValue(molorb, eigVecsComplex, kPointsHchain, kIndexesHchain, valueOnGrid, this%config%useGPU)
    ! CheckReal sum over grid
    expected = (113.9831688331955_dp, 45.30115350686194_dp)
    actual = sum(valueOnGrid) * gridVol
    print *, "Total charge:", actual
    @:CHECK(is_close(real(actual), real(expected), rtol=rtol))
    @:CHECK(is_close(aimag(actual), aimag(expected), rtol=rtol))

    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))

      @:CHECK(is_close(real(actual), real(expected), rtol=rtol))
      @:CHECK(is_close(aimag(actual), aimag(expected), rtol=rtol))
    end do
  end subroutine TConfiguredTest_complex_allStates_run




  function makeTest(prefix, launchConfig) result(testObj)
    character(*), intent(in) :: prefix
    type(TLaunchConfig), intent(in) :: launchConfig
    type(test_item) :: testObj

    character(:), allocatable :: name

    name = trim(prefix)
    if (launchConfig%useRadialLut) then
      name = trim(name) // "_LUT"
    else
      name = trim(name) // "_Direct"
    end if
    if (launchConfig%useGPU) then
      name = trim(name) // "_GPU"
    else
      name = trim(name) // "_CPU"
    end if

    select case (trim(prefix))
    case ("real_totChrg")
      testObj = test_item(TConfiguredTest_real_totChrg(name=name, config=launchConfig))
    case ("real_atomDens")
      testObj = test_item(TConfiguredTest_real_atomDens(name=name, config=launchConfig))
    case ("real_allStates")
      testObj = test_item(TConfiguredTest_real_allStates(name=name, config=launchConfig))
    case ("complex_totChrg")
      testObj = test_item(TConfiguredTest_complex_totChrg(name=name, config=launchConfig))
    case ("complex_allStates")
      testObj = test_item(TConfiguredTest_complex_allStates(name=name, config=launchConfig))
    case default
      print *, "Unknown test case prefix: ", trim(prefix)
      stop 1
    end select




  end function makeTest




  !> Registers test cases with Fortuno
  function tests()
    type(test_list) :: tests

    integer :: i

    tests = test_list([&
        suite("RealTotChrg", test_list([&
            (makeTest("real_totChrg", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("RealAtomDens", test_list([&
            (makeTest("real_atomDens", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("RealAllStates", test_list([&
            (makeTest("real_allStates", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("ComplexTotChrg", test_list([&
            (makeTest("complex_totChrg", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("ComplexAllStates", test_list([&
            (makeTest("complex_allStates", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ]))&
    ])

    $:STOP_ON_MISSING_TEST_ITEMS()

  end function tests



end module test_libwavegrid_simple
